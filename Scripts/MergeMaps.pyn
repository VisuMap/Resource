# MergeMaps.pyn
#
# Caputure tSNE maps at different exaggeration levels ( i.e. scale ) and
# then merging them into a single tSNE maps.
#
markerList = [100*k for k in range(2,11)]
bsList = vv.Dataset.BodyListEnabled()
showMaps = False

cs = New.CsObject('''
	public void CaptureOneMap(INumberTable nt, List<IBody> bsList, int column0) {
   	for(int k=0; k<bsList.Count; k++) {
			IBody b = bsList[k];
			double[] R = nt.Matrix[k] as double[];
			R[column0+0] = b.X;
			R[column0+1] = b.Y;
			R[column0+2] = b.Z;
		}
   }
''')

# Callback function to extract map during t-SNE training process.
def BodyMoved():
	if pp.CurrentLoops in markerList:
		idx = markerList.index(pp.CurrentLoops)
		dsTable = pp.Tag
		cs.CaptureOneMap(dsTable, bsList, 3*idx);
		if showMaps:
			mp = New.Map3DView().Show()
			mp.Title = "Epochs: " + str(pp.CurrentLoops)

# Run t-SNE with some default behaviors.
def RunTsne(mds, trainEpochs, is3D):
	mds.MaxLoops = trainEpochs
	mds.RefreshFreq = 50
	mds.Is3D = is3D
	mds.TracingType = 6
	mds.Repeats = 1
	mds.Show().Reset().Start()
	if mds.CurrentLoops != mds.MaxLoops:
		vv.Return()
	else:
		mds.Close()

# Create dataset from maps extracted during the t-SNE training processes.
def CreateMapDataset(pp=0.05, initExa=4.0, finalExa=1.25):
	mds = New.TsneMap()
	mds.InitialExaggeration = initExa
	mds.FinalExaggeration = finalExa
	mds.PerplexityRatio = pp
	mds.AutoNormalizing = False
	mds.AutoScaling = True	
	mds.Tag = New.NumberTable(bsList, 3*len(markerList))
	vv.EventManager.OnBodyMoved('@BodyMoved()', mds)
	vv.Map.Depth = 0.5 * (vv.Map.Height + vv.Map.Width)
	RunTsne(mds, markerList[-1], True)
	return mds.Tag

# Create dataset from multiple maps of the same dataset.
def ReadMapList( mapList ):
	dimList = [vv.Dataset.ReadMap(mn).Dimension for mn in mapList]
	rows = vv.Dataset.BodyListEnabled().Count
	nt = New.NumberTable(rows, sum(dimList))
	dimOffset = 0
	for k, mn in enumerate(mapList):
		bsList = vv.Dataset.ReadMapBodyList(mn, True)
		for R, b in zip(nt.Matrix, bsList):
			R[dimOffset + 0] = b.X
			R[dimOffset + 1] = b.Y
			if dimList[k] == 3:
				R[dimOffset + 2] = b.Z
		dimOffset += dimList[k]
	for k in range(rows):
		nt.RowSpecList[k].CopyFromBody(bsList[k])
	return nt

# Create a t-SNE map with specific dataset and metric
def CreateMdsMap(nt, mtr="EuclideanMetric", pp=0.15, initExa=10.0, finalExa=1.0, epochs=markerList[-1]):
	mds = New.TsneMap()
	mds.ChangeTrainingData(nt, mtr)
	mds.InitialExaggeration = initExa
	mds.FinalExaggeration = finalExa
	mds.PerplexityRatio = pp  # High PP is key for low dimensional data.
	mds.AutoNormalizing = True
	mds.AutoScaling = False
	RunTsne(mds, epochs, False)

#-----------------------------------------------------------------

dsTable = CreateMapDataset(initExa=4.0)
CreateMdsMap(dsTable, pp=0.1, initExa=10.0)

'''
dsTable = ReadMapList(['A2', 'A3'])

vv.Dataset.AddMap()
CreateMdsMap(dsTable, "Numerical.Square Root")
CreateMdsMap(dsTable, "Numerical.Harmonic Mean")
CreateMdsMap(dsTable, "Numerical.City Block")

New.HeatMap(dsTable).Show()

for k in range(2):
	if k != 0: vv.Dataset.AddMap()
	dsTable = CreateMapDataset()
	CreateMdsMap(dsTable)
'''
