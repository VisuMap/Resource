# MergeMaps.pyn
#
# Caputure tSNE maps at different exaggeration levels ( i.e. scale ) and
# then merging them into a single tSNE maps.
#
import math, time

# Callback function to extract map during t-SNE training process.
rmInitSize, rmStepSize,  recordMarker = 0, 0, 0
def BodyMoved():
	global recordMarker

	dsTable = pp.Tag
	columns = dsTable.Tag
	mapDim = 3 if pp.Is3D else 2

	if (pp.CurrentLoops == 0) or (columns + mapDim > dsTable.Columns):
		return	
	if (pp.GlyphSpan < recordMarker) and (pp.CurrentLoops != pp.MaxLoops):
		return
	bsList = vv.Dataset.BodyListEnabled()
	if IsCollapsed(bsList, mapDim, pp.GlyphScale): # the map is still collapsed
		return

	dsTable.CopyValuesFrom(bsList, pp.Is3D, columns)
	fct = 1.0 if recordMarker < 3.0 else 2.0
	recordMarker += fct*rmStepSize   # set the next recordMarker threashold.
	dsTable.Tag = columns + mapDim

# Run t-SNE with some default behaviors.
def RunTsne(mds):
	mds.TracingType = 6
	mds.Repeats = 1
	mds.StagedTraining = False
	mds.ReadOnly = True
	mds.HistStepSize = 2.0
	mds.Show().Reset().Start()
	if mds.CurrentLoops != mds.MaxLoops:
		vv.Title = 'Training aborted'
		vv.Return()		
	else:
		mds.Close()

def MergeSmallGroups(fList, minFeatures, sorted=False):
	newList = fList[0:1]
	for f in fList[1:]:
		if f.Count < minFeatures:
			newList[-1].AddRange(f)
		else:
			newList.append(f)
	if (newList[0].Count < minFeatures) and ( len(newList) >= 2 ) :
		firstGroup = newList.pop(0)
		newList[0].AddRange(firstGroup)
	if sorted:
		newList.sort(key=len, reverse=True)
	return newList

# Create dataset from maps extracted during the t-SNE training processes.
def CreateMapDataset(is3D=True, initSize=0.2, stepSize=0.5, ppl=None, ex0=None, ex1=None, epochs=0):
	global recordMarker
	global rmStepSize
	global rmInitSize
	rmInitSize = initSize
	rmStepSize = stepSize
	mds = New.TsneMap()
	if ppl != None: mds.PerplexityRatio = ppl 
	if ex0 != None: mds.InitialExaggeration = ex0
	if ex1 != None: mds.FinalExaggeration = ex1
	if epochs != 0: mds.MaxLoops = epochs
	mds.AutoNormalizing = False
	mds.AutoScaling = True
	mds.CentralizingData = True
	mds.RefreshFreq = 10
	mds.Is3D = is3D
	mapDim = 3 if is3D else 2
	vv.Map.MapType = "Cube" if is3D else "Rectangle"
	bsList = vv.Dataset.BodyListEnabled()
	recordMarker = rmInitSize    	# Initial recordMarker.
	maxRecords = 50
	nt = New.NumberTable(bsList, mapDim*maxRecords)
	mds.Tag = nt
	nt.Tag = 0
	csList = nt.ColumnSpecList
	for k in range(maxRecords):
		csList[mapDim*k].Type = k
		csList[mapDim*k+1].Type = k
		if is3D:
			csList[mapDim*k+2].Type = k
		
	vv.EventManager.OnBodyMoved('@BodyMoved()', mds)
	vv.Map.Depth = 0.5 * (vv.Map.Height + vv.Map.Width)
	RunTsne(mds)
	dsTable = mds.Tag
	dsTable = dsTable.SliceColumn(0, dsTable.Tag)
	vv.Echo(f'Dataset created:  {dsTable.Rows}x{dsTable.Columns}')
	return dsTable

# Create dataset from multiple maps of the same dataset.
def ReadMapList( mapList ):
	mapList = mapList.split('|')
	dimList = [vv.Dataset.ReadMap(mn).Dimension for mn in mapList]
	rows = vv.Dataset.BodyListEnabled().Count
	nt = New.NumberTable(rows, sum(dimList))
	dimOffset = 0
	csList = nt.ColumnSpecList
	for k, mn in enumerate(mapList):
		bsList = vv.Dataset.ReadMapBodyList(mn, True)
		mapDim = dimList[k]
		nt.CopyValuesFrom(bsList, mapDim == 3, dimOffset)
		for n in range(mapDim):
			csList[dimOffset + n].Type = k
		dimOffset += mapDim				
	for k in range(rows):
		nt.RowSpecList[k].CopyFromBody(bsList[k])
	vv.Echo(f'Dataset created:  {nt.Rows}x{nt.Columns}')
	return nt

def Settings(nt, mds):
	global dsType
	return f'Settings: {dsType}:{nt.Rows}x{nt.Columns}; {mds.MaxLoops}; {mds.PerplexityRatio}; {mds.InitialExaggeration}/{mds.FinalExaggeration}, {time.asctime()}'

# Create a t-SNE map with specific dataset and metric
def CreateMdsMap(nt, mtr="EuclideanMetric", is3D=False, ppl=0.15, ex0=10.0, ex1=1.0, epochs=0):
	mds = New.TsneMap()
	if epochs != 0: mds.MaxLoops = epochs
	mds.ChangeTrainingData(nt, mtr)
	mds.Tag = nt
	mds.PerplexityRatio = ppl  # High PP is key for low dimensional data.
	mds.InitialExaggeration = ex0
	mds.FinalExaggeration = ex1
	mds.AutoNormalizing = True
	mds.AutoScaling = False
	mds.Is3D = is3D
	mds.RefreshFreq = 100
	vv.Map.MapType="Rectangle"
	vv.Map.Description = Settings(nt, mds)
	RunTsne(mds)

def ShowSelectedMap():
	nn = pp.SelectedItems.Count
	if (nn != pp.ScrollingSteps) or (pp.SelectionMode != 1):	
		return	
	bList = New.BodyList(pp.GetSelectedNumberTable())
	if nn==3:
		map = New.Map3DView(bList)
		map.ResetView(0)
	else:
		map = New.MapSnapshot(bList)
		map.ResetSize()
	map.Show()		

def ShowDataset(dsTable):
	hm = New.HeatMap(dsTable)
	hm.Show()
	hm.SelectionMode = 1
	hm.ScrollingSteps = 3 if dsTable.ColumnSpecList[2].Group == 0 else 2 
	hm.Title = 'Data Dimension: ' + str(dsTable.Rows) + 'x' + str(dsTable.Columns)
	hm.AddEventHandler('ItemsSelected', '@ShowSelectedMap()')

def ShowFeatures(featureList):
	szList = [f.Count for f in featureList]
	vv.Echo(f'Features: {szList},   Total: {sum(szList)}')

def ShowDataset2(ds):
	mDim = 3 if ds.ColumnSpecList[2].Group == 0 else 2
	bs = New.BodyList(ds)
	if mDim == 3:
		map = New.Map3DView(bs).Show()
		map.ResetView(0)
		map.ShowBoundingBox = False
	else:
		map = New.MapSnapshot(bs).Show()
		map.ResetSize()
	map.CentralizeView()
	for k in range(2):
		for col in range(0, ds.Columns, mDim):
			bodyList = New.BodyList( ds.SliceColumn(col, col+mDim) )
			map.MoveBodiesTo(bodyList, steps=15, msPause=75, loops=0, loopPause=0)
			map.Title = f'N: {k}:{col}:{col+mDim}'
			vv.Sleep(250)
			if mDim == 2 and col == 3*mDim:
				map.CentralizeView()
		vv.Sleep(1000)
	map.Close()

def FeaturesToDataset(featureList, is3D=False, ppl=None, ex0=None, ex1=None, epochs=0):
	nt = vv.GetNumberTable()
	allFeatures = { cs.Id for cs in nt.ColumnSpecList }
	for f in featureList:
		if not set(f).issubset( allFeatures ):
			vv.Message('Some features are not table columns')
			vv.Return()
	mds = New.TsneMap()
	mds.Show()
	if ppl != None: mds.PerplexityRatio = ppl 
	if ex0 != None: mds.InitialExaggeration = ex0
	if ex1 != None: mds.FinalExaggeration = ex1
	if epochs != 0: mds.MaxLoops = epochs
	mds.Is3D = is3D
	mapDim = 3 if is3D else 2
	mds.ReadOnly = True
	mds.RefreshFreq = 100
	mds.AutoNormalizing = False
	mds.AutoScaling = False
	mds.GlyphScale = 50
	mds.CentralizingData = True
	mds.TracingType = 6
	mds.Repeats = 1
	bsList = vv.Dataset.BodyListEnabled()
	L = len(featureList)
	dimOffset = 0

	dsTable = New.NumberTable(bsList, mapDim*L)
	mds.Tag = dsTable
	csList = dsTable.ColumnSpecList
	for k in range(L):
		for dm in range(mapDim):
			csList[mapDim*k + dm].Type = k
	szList = [f.Count for f in featureList]
	for idx, fs in enumerate(featureList):  
		vv.Title = f'Reducing Feature Group: {fs.Count} out of {szList}'
		ds = nt.SelectColumnsById(fs)
		mds.ChangeTrainingData(ds)
		mds.Reset()
		mds.Start()
		if mds.CurrentLoops != mds.MaxLoops:
			vv.Return()
		dsTable.CopyValuesFrom(bsList, is3D, dimOffset)
		dimOffset += mapDim
	mds.Close()
	return dsTable

def FeaturesToDatasetByPCA(featureList, nPCA=3):
	nt = vv.GetNumberTable()
	bsList = vv.Dataset.BodyListEnabled()
	dsTable = New.NumberTable(bsList, nPCA*len(featureList))
	csList = dsTable.ColumnSpecList
	dstDim = 0
	for idx, fs in enumerate(featureList):
		ds = nt.SelectColumnsById(fs)
		mPCA = ds.DoPcaReduction(nPCA)
		dsTable.CopyValuesFrom(mPCA, 0, dstDim)
		for k in range(mPCA.Columns):
			csList[dstDim+k].Type = idx
		dstDim += mPCA.Columns
	dsTable = dsTable.SliceColumn(0, dstDim)
	return dsTable

def GroupesToFeatures(gList):
	gm = vv.GroupManager
	fList = []
	for g in gList:
		f = gm.GetGroupLabels(g)
		if f is not None:
			fList.append(f)
	return fList

def AtlasMap2Features(mapItem):  
	mp = vv.AtlasManager.OpenMap(None, mapItem)
	if mp is None:
		vv.Message(f'Cannot load map item: {mapItem}')
		vv.Return()
	fList = BodyList2Features(mp.BodyList)
	fList = MergeSmallGroups(fList, 5)
	vv.Echo(f'Feature groups loaded: {[f.Count for f in fList]}')
	mp.Close()
	return fList

def BodyList2Features(bodyList):
	maxType = 0
	for b in bodyList:
		if b.Type > maxType:
			maxType = b.Type
	fList = [New.StringArray() for k in range(maxType + 1)]
	for b in bodyList:
		if not b.Disabled:
			fList[b.Type].Add(b.Id)
	return fList

def FeaturesByScale(maxGroups = 10, minFeatures = 20):
	fList = [New.StringArray() for k in range(maxGroups)]
	nt = vv.GetNumberTable()
	colMean = nt.ColumnMean()
	#colMean = nt.ColumnVariance()
	minV = 9e20
	maxV = -minV
	for k in range(nt.Columns):
		v = colMean[k].Value
		minV = min(minV, v)
		maxV = max(maxV, v)
	maxV = math.log1p(maxV)
	minV = math.log1p(minV)
	stepSize = (maxV - minV)/maxGroups
	csList = nt.ColumnSpecList
	for k in range(nt.Columns):
		it = colMean[k]
		idx = int( (math.log1p(it.Value) - minV)/stepSize )
		idx = min(idx, maxGroups-1)
		fList[idx].Add(it.Id)
	# merge small groups
	fList = MergeSmallGroups(fList, minFeatures)
	vv.Echo(f'Feature groups created: {[f.Count for f in fList]}')
	return fList

def SaveFeatureList(featureList, groupName):
	glist = ['$'.join(f) for f in featureList]
	vv.GroupManager.SetGroupLabels(groupName, glist)

def LoadFeatureList(groupName):
	glist = vv.GroupManager.GetGroupLabels(groupName)
	if glist is None:
		vv.Message(f'Group {groupName} doesnot exist!')
		vv.Return()
	return [New.StringArray(g.split('$')) for g in glist]

isFirstMap = True
def SwitchToNewMap():
	global isFirstMap
	if isFirstMap:
		isFirstMap = False
	else:
		vv.Dataset.AddMap()

# Check whether a map has collapsed dimensions
isUnfold = False
def IsCollapsed(bsList, mapDim, spanFactor):
	global isUnfold
	if isUnfold:
		return False
	nt = New.NumberTable(bsList, mapDim)
	ev = New.NumberArray()
	nt.GetPcaEigenvectors(ev, mapDim)
	ev = [math.sqrt(v/spanFactor) for v in ev]
	minEv = ev[1] if mapDim == 3 else ev[0]
	vv.Echo(f'{ev[0]}, {ev[1]}, {ev[2]}')
	isUnfold = (minEv > 0.2)
	return not isUnfold

#-------------------------------------------------------------------------

def CreateDataset(_dsType):
	global dsType
	global dsTable
	global featureList
	dsType = _dsType

	vv.Echo(f'Creating DS: {dsType}')

	SwitchToNewMap()

	if dsType == 0:
		dsTable = CreateMapDataset(stepSize=0.5, is3D=True, ex0=8.0, ex1=1.0, ppl=0.1)
	elif dsType == 1:
		featureList = FeaturesByScale(maxGroups=16, minFeatures=20)
	elif dsType == 2:
		featureList = AtlasMap2Features('i25')
	elif dsType == 3:
		dsTable = ReadMapList('A1|A2|A2|A2|A2')
	elif dsType == 4:
		featureList = Group2Features([f'G{k}' for k in range(20)])
	elif dsType == 5:
		featureList = GroupesToFeatures('Chr17_List')
	elif dsType == 6:
		SaveFeatureList(featureList, 'Chr17_List')
	
	if dsType in [1,2,4,5]:
		#dsTable = FeaturesToDatasetByPCA(featureList, nPCA=5)
		dsTable = FeaturesToDataset(featureList, is3D=True, ex0=8.0, ex1=1.0, ppl=0.1)

for k in [0]:
	CreateDataset(k)
	CreateMdsMap(dsTable, is3D=False, ex0=8.0, ex1=1.0, ppl=0.05)

'''-----------------------------------------------------------------------

ShowFeatures(featureList)

ShowDataset(dsTable)

for k in [0,0,0,1,1,1]:
	CreateDataset(k)
	CreateMdsMap(dsTable, is3D=False, ex0=6.0, ex1=1.0, ppl=0.1)

cm = New.ClusterManager().Show()

ShowDataset2(dsTable)

for p in [0.1, 0.05, 0.01]:
	vv.Dataset.AddMap()
	CreateMdsMap(dsTable, ppl=p)

for sk in [0, 6, 12]:
	vv.Dataset.AddMap()
	CreateMdsMap(dsTable.SliceColumn(sk), ppl=0.05)

dsTable = dsTable.SliceColumn(3, 0)

vv.GuiManager.ReuseLastWindow = False

CreateMdsMap(dsTable, "Numerical.City Block")

hm = New.HeatMap(dsTable).Show()
hm.SelectedItems = hm.AllItems
hm.ClickMenu('PyUtils/UMAP')

'''
